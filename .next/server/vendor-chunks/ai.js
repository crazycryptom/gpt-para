"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>{\n            tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\";\n        })) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            },\n            generateId\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = generateId();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else if (streamedResponse.startsWith('{\"tool_calls\":')) {\n                responseMessage[\"tool_calls\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (streamedResponse.startsWith('{\"tool_calls\":')) {\n            const parsedToolCalls = JSON.parse(streamedResponse).tool_calls;\n            responseMessage[\"tool_calls\"] = parsedToolCalls;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, onResponse, onFinish, onError, credentials, headers, body, generateId = nanoid } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n        if (isComplexMode) {\n            for await (const { type, value } of readDataStream(reader, {\n                isAborted: ()=>abortController === null\n            })){\n                switch(type){\n                    case \"text\":\n                        {\n                            result += value;\n                            setCompletion(result);\n                            break;\n                        }\n                    case \"data\":\n                        {\n                            onData == null ? void 0 : onData(value);\n                            break;\n                        }\n                }\n            }\n        } else {\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                setCompletion(result);\n                if (abortController === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction experimental_useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a, _b;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            body: JSON.stringify({\n                ...body,\n                // always use user-provided threadId when available:\n                threadId: (_b = threadIdParam != null ? threadIdParam : threadId) != null ? _b : null,\n                message: input,\n                // optional request data:\n                data: requestOptions == null ? void 0 : requestOptions.data\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        try {\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : \"\",\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnRTtBQUMzQjs7QUNjckMsSUFBTU0saUJBQWtEO0lBQ3REQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFFQSxJQUFNRyx5QkFJRjtJQUNGTixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQ0VBLFNBQVMsUUFDVCxPQUFPQSxVQUFVLFlBQ2pCLENBQUUsb0JBQW1CQSxLQUFBLEtBQ3JCLE9BQU9BLE1BQU1JLGFBQUEsS0FBa0IsWUFDL0JKLE1BQU1JLGFBQUEsSUFBaUIsUUFDdkIsQ0FBRSxXQUFVSixNQUFNSSxhQUFBLEtBQ2xCLENBQUUsZ0JBQWVKLE1BQU1JLGFBQUEsS0FDdkIsT0FBT0osTUFBTUksYUFBQSxDQUFjTixJQUFBLEtBQVMsWUFDcEMsT0FBT0UsTUFBTUksYUFBQSxDQUFjQyxTQUFBLEtBQWMsVUFDekM7WUFDQSxNQUFNLElBQUlKLE1BQ1I7UUFFSjtRQUVBLE9BQU87WUFDTEMsTUFBTTtZQUNORjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQU1NLGlCQUE0RDtJQUNoRVQsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLENBQUNPLE1BQU1DLE9BQUEsQ0FBUVIsUUFBUTtZQUN6QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBRUEsSUFBTVMsa0JBQW9EO0lBQ3hEWixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMs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bXMvLi4vdXNlLWNoYXQudHM/ODgyOCIsIndlYnBhY2s6Ly91bm1zLy4uLy4uL3NoYXJlZC9zdHJlYW0tcGFydHMudHM/YzRhOCIsIndlYnBhY2s6Ly91bm1zLy4uLy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzPzE4ZjEiLCJ3ZWJwYWNrOi8vdW5tcy8uLi8uLi9zaGFyZWQvdXRpbHMudHM/ZjhjZiIsIndlYnBhY2s6Ly91bm1zLy4uLy4uL3NoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzPzY1ZTAiLCJ3ZWJwYWNrOi8vdW5tcy8uLi8uLi9zaGFyZWQvY2FsbC1jaGF0LWFwaS50cz9iNTViIiwid2VicGFjazovL3VubXMvLi4vLi4vc2hhcmVkL3Byb2Nlc3MtY2hhdC1zdHJlYW0udHM/OGQ3ZiIsIndlYnBhY2s6Ly91bm1zLy4uL3VzZS1jb21wbGV0aW9uLnRzP2FlN2YiLCJ3ZWJwYWNrOi8vdW5tcy8uLi8uLi9zaGFyZWQvY2FsbC1jb21wbGV0aW9uLWFwaS50cz84NTI1Iiwid2VicGFjazovL3VubXMvLi4vdXNlLWFzc2lzdGFudC50cz8yODEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNXUiwgeyBLZXllZE11dGF0b3IgfSBmcm9tICdzd3InO1xuaW1wb3J0IHsgY2FsbENoYXRBcGkgfSBmcm9tICcuLi9zaGFyZWQvY2FsbC1jaGF0LWFwaSc7XG5pbXBvcnQgeyBwcm9jZXNzQ2hhdFN0cmVhbSB9IGZyb20gJy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtJztcbmltcG9ydCB0eXBlIHtcbiAgQ2hhdFJlcXVlc3QsXG4gIENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgQ3JlYXRlTWVzc2FnZSxcbiAgSWRHZW5lcmF0b3IsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVXNlQ2hhdE9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMnO1xuaW1wb3J0IHR5cGUge1xuICBSZWFjdFJlc3BvbnNlUm93LFxuICBleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZSxcbn0gZnJvbSAnLi4vc3RyZWFtcy9zdHJlYW1pbmctcmVhY3QtcmVzcG9uc2UnO1xuZXhwb3J0IHR5cGUgeyBDcmVhdGVNZXNzYWdlLCBNZXNzYWdlLCBVc2VDaGF0T3B0aW9ucyB9O1xuXG5leHBvcnQgdHlwZSBVc2VDaGF0SGVscGVycyA9IHtcbiAgLyoqIEN1cnJlbnQgbWVzc2FnZXMgaW4gdGhlIGNoYXQgKi9cbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgLyoqIFRoZSBlcnJvciBvYmplY3Qgb2YgdGhlIEFQSSByZXF1ZXN0ICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCBFcnJvcjtcbiAgLyoqXG4gICAqIEFwcGVuZCBhIHVzZXIgbWVzc2FnZSB0byB0aGUgY2hhdCBsaXN0LiBUaGlzIHRyaWdnZXJzIHRoZSBBUEkgY2FsbCB0byBmZXRjaFxuICAgKiB0aGUgYXNzaXN0YW50J3MgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJIGNhbGxcbiAgICovXG4gIGFwcGVuZDogKFxuICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgIGNoYXRSZXF1ZXN0T3B0aW9ucz86IENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogUmVsb2FkIHRoZSBsYXN0IEFJIGNoYXQgcmVzcG9uc2UgZm9yIHRoZSBnaXZlbiBjaGF0IGhpc3RvcnkuIElmIHRoZSBsYXN0XG4gICAqIG1lc3NhZ2UgaXNuJ3QgZnJvbSB0aGUgYXNzaXN0YW50LCBpdCB3aWxsIHJlcXVlc3QgdGhlIEFQSSB0byBnZW5lcmF0ZSBhXG4gICAqIG5ldyByZXNwb25zZS5cbiAgICovXG4gIHJlbG9hZDogKFxuICAgIGNoYXRSZXF1ZXN0T3B0aW9ucz86IENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgcmVxdWVzdCBpbW1lZGlhdGVseSwga2VlcCB0aGUgZ2VuZXJhdGVkIHRva2VucyBpZiBhbnkuXG4gICAqL1xuICBzdG9wOiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBgbWVzc2FnZXNgIHN0YXRlIGxvY2FsbHkuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG9cbiAgICogZWRpdCB0aGUgbWVzc2FnZXMgb24gdGhlIGNsaWVudCwgYW5kIHRoZW4gdHJpZ2dlciB0aGUgYHJlbG9hZGAgbWV0aG9kXG4gICAqIG1hbnVhbGx5IHRvIHJlZ2VuZXJhdGUgdGhlIEFJIHJlc3BvbnNlLlxuICAgKi9cbiAgc2V0TWVzc2FnZXM6IChtZXNzYWdlczogTWVzc2FnZVtdKSA9PiB2b2lkO1xuICAvKiogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0ICovXG4gIGlucHV0OiBzdHJpbmc7XG4gIC8qKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcbiAgLyoqIEFuIGlucHV0L3RleHRhcmVhLXJlYWR5IG9uQ2hhbmdlIGhhbmRsZXIgdG8gY29udHJvbCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0ICovXG4gIGhhbmRsZUlucHV0Q2hhbmdlOiAoXG4gICAgZTpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4gdm9pZDtcbiAgLyoqIEZvcm0gc3VibWlzc2lvbiBoYW5kbGVyIHRvIGF1dG9tYXRpY2FsbHkgcmVzZXQgaW5wdXQgYW5kIGFwcGVuZCBhIHVzZXIgbWVzc2FnZSAqL1xuICBoYW5kbGVTdWJtaXQ6IChcbiAgICBlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gdm9pZDtcbiAgbWV0YWRhdGE/OiBPYmplY3Q7XG4gIC8qKiBXaGV0aGVyIHRoZSBBUEkgcmVxdWVzdCBpcyBpbiBwcm9ncmVzcyAqL1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIC8qKiBBZGRpdGlvbmFsIGRhdGEgYWRkZWQgb24gdGhlIHNlcnZlciB2aWEgU3RyZWFtRGF0YSAqL1xuICBkYXRhPzogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQ7XG59O1xuXG50eXBlIFN0cmVhbWluZ1JlYWN0UmVzcG9uc2VBY3Rpb24gPSAocGF5bG9hZDoge1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn0pID0+IFByb21pc2U8ZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2U+O1xuXG5jb25zdCBnZXRTdHJlYW1lZFJlc3BvbnNlID0gYXN5bmMgKFxuICBhcGk6IHN0cmluZyB8IFN0cmVhbWluZ1JlYWN0UmVzcG9uc2VBY3Rpb24sXG4gIGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCxcbiAgbXV0YXRlOiBLZXllZE11dGF0b3I8TWVzc2FnZVtdPixcbiAgbXV0YXRlU3RyZWFtRGF0YTogS2V5ZWRNdXRhdG9yPEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkPixcbiAgZXhpc3RpbmdEYXRhOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCxcbiAgZXh0cmFNZXRhZGF0YVJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxhbnk+LFxuICBtZXNzYWdlc1JlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxNZXNzYWdlW10+LFxuICBhYm9ydENvbnRyb2xsZXJSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4sXG4gIGdlbmVyYXRlSWQ6IElkR2VuZXJhdG9yLFxuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkLFxuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHM/OiBib29sZWFuLFxuKSA9PiB7XG4gIC8vIERvIGFuIG9wdGltaXN0aWMgdXBkYXRlIHRvIHRoZSBjaGF0IHN0YXRlIHRvIHNob3cgdGhlIHVwZGF0ZWQgbWVzc2FnZXNcbiAgLy8gaW1tZWRpYXRlbHkuXG4gIGNvbnN0IHByZXZpb3VzTWVzc2FnZXMgPSBtZXNzYWdlc1JlZi5jdXJyZW50O1xuICBtdXRhdGUoY2hhdFJlcXVlc3QubWVzc2FnZXMsIGZhbHNlKTtcblxuICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCA9IHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHNcbiAgICA/IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzXG4gICAgOiBjaGF0UmVxdWVzdC5tZXNzYWdlcy5tYXAoXG4gICAgICAgICh7IHJvbGUsIGNvbnRlbnQsIG5hbWUsIGZ1bmN0aW9uX2NhbGwsIHRvb2xfY2FsbHMsIHRvb2xfY2FsbF9pZCB9KSA9PiAoe1xuICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgLi4uKG5hbWUgIT09IHVuZGVmaW5lZCAmJiB7IG5hbWUgfSksXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBmdW5jdGlvbl9jYWxsLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLih0b29sX2NhbGxzICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgICAgdG9vbF9jYWxsczogdG9vbF9jYWxscyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gIGlmICh0eXBlb2YgYXBpICE9PSAnc3RyaW5nJykge1xuICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgYXJlIGhhbmRsaW5nIGEgU2VydmVyIEFjdGlvbi4gTm8gY29tcGxleCBtb2RlIGhhbmRsaW5nIG5lZWRlZC5cblxuICAgIGNvbnN0IHJlcGx5SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiAnJyxcbiAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgIH07XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkUm93KHByb21pc2U6IFByb21pc2U8UmVhY3RSZXNwb25zZVJvdz4pIHtcbiAgICAgIGNvbnN0IHsgY29udGVudCwgdWksIG5leHQgfSA9IGF3YWl0IHByb21pc2U7XG5cbiAgICAgIC8vIFRPRE86IEhhbmRsZSBmdW5jdGlvbiBjYWxscy5cbiAgICAgIHJlc3BvbnNlTWVzc2FnZVsnY29udGVudCddID0gY29udGVudDtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZVsndWknXSA9IGF3YWl0IHVpO1xuXG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCB7IC4uLnJlc3BvbnNlTWVzc2FnZSB9XSwgZmFsc2UpO1xuXG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBhd2FpdCByZWFkUm93KG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gYXBpKHtcbiAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIGFzIE1lc3NhZ2VbXSxcbiAgICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgIH0pIGFzIFByb21pc2U8UmVhY3RSZXNwb25zZVJvdz47XG4gICAgICBhd2FpdCByZWFkUm93KHByb21pc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIG1lc3NhZ2VzIGlmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZU1lc3NhZ2U7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgY2FsbENoYXRBcGkoe1xuICAgIGFwaSxcbiAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQsXG4gICAgYm9keToge1xuICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgLi4uY2hhdFJlcXVlc3Qub3B0aW9ucz8uYm9keSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC5mdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uczogY2hhdFJlcXVlc3QuZnVuY3Rpb25zLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbCxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LnRvb2xzICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICB0b29sczogY2hhdFJlcXVlc3QudG9vbHMsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC50b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgdG9vbF9jaG9pY2U6IGNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlLFxuICAgICAgfSksXG4gICAgfSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uY2hhdFJlcXVlc3Qub3B0aW9ucz8uaGVhZGVycyxcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBtZXNzYWdlXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi4oZXhpc3RpbmdEYXRhIHx8IFtdKSwgLi4uKGRhdGEgfHwgW10pXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgb25GaW5pc2gsXG4gICAgZ2VuZXJhdGVJZCxcbiAgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhdCh7XG4gIGFwaSA9ICcvYXBpL2NoYXQnLFxuICBpZCxcbiAgaW5pdGlhbE1lc3NhZ2VzLFxuICBpbml0aWFsSW5wdXQgPSAnJyxcbiAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBnZW5lcmF0ZUlkID0gbmFub2lkLFxufTogT21pdDxVc2VDaGF0T3B0aW9ucywgJ2FwaSc+ICYge1xuICBhcGk/OiBzdHJpbmcgfCBTdHJlYW1pbmdSZWFjdFJlc3BvbnNlQWN0aW9uO1xuICBrZXk/OiBzdHJpbmc7XG59ID0ge30pOiBVc2VDaGF0SGVscGVycyB7XG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkIGZvciB0aGUgY2hhdCBpZiBub3QgcHJvdmlkZWQuXG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGlkS2V5ID0gaWQgPz8gaG9va0lkO1xuICBjb25zdCBjaGF0S2V5ID0gdHlwZW9mIGFwaSA9PT0gJ3N0cmluZycgPyBbYXBpLCBpZEtleV0gOiBpZEtleTtcblxuICAvLyBTdG9yZSBhIGVtcHR5IGFycmF5IGFzIHRoZSBpbml0aWFsIG1lc3NhZ2VzXG4gIC8vIChpbnN0ZWFkIG9mIHVzaW5nIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUgdGhhdCBnZXRzIHJlLWNyZWF0ZWQgZWFjaCB0aW1lKVxuICAvLyB0byBhdm9pZCByZS1yZW5kZXJzOlxuICBjb25zdCBbaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2tdID0gdXNlU3RhdGUoW10pO1xuXG4gIC8vIFN0b3JlIHRoZSBjaGF0IHN0YXRlIGluIFNXUiwgdXNpbmcgdGhlIGNoYXRJZCBhcyB0aGUga2V5IHRvIHNoYXJlIHN0YXRlcy5cbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1I8TWVzc2FnZVtdPihcbiAgICBbY2hhdEtleSwgJ21lc3NhZ2VzJ10sXG4gICAgbnVsbCxcbiAgICB7IGZhbGxiYWNrRGF0YTogaW5pdGlhbE1lc3NhZ2VzID8/IGluaXRpYWxNZXNzYWdlc0ZhbGxiYWNrIH0sXG4gICk7XG5cbiAgLy8gV2Ugc3RvcmUgbG9hZGluZyBzdGF0ZSBpbiBhbm90aGVyIGhvb2sgdG8gc3luYyBsb2FkaW5nIHN0YXRlcyBhY3Jvc3MgaG9vayBpbnZvY2F0aW9uc1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjxib29sZWFuPihcbiAgICBbY2hhdEtleSwgJ2xvYWRpbmcnXSxcbiAgICBudWxsLFxuICApO1xuXG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1I8XG4gICAgSlNPTlZhbHVlW10gfCB1bmRlZmluZWRcbiAgPihbY2hhdEtleSwgJ3N0cmVhbURhdGEnXSwgbnVsbCk7XG5cbiAgY29uc3QgeyBkYXRhOiBlcnJvciA9IHVuZGVmaW5lZCwgbXV0YXRlOiBzZXRFcnJvciB9ID0gdXNlU1dSPFxuICAgIHVuZGVmaW5lZCB8IEVycm9yXG4gID4oW2NoYXRLZXksICdlcnJvciddLCBudWxsKTtcblxuICAvLyBLZWVwIHRoZSBsYXRlc3QgbWVzc2FnZXMgaW4gYSByZWYuXG4gIGNvbnN0IG1lc3NhZ2VzUmVmID0gdXNlUmVmPE1lc3NhZ2VbXT4obWVzc2FnZXMgfHwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcyB8fCBbXTtcbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgLy8gQWJvcnQgY29udHJvbGxlciB0byBjYW5jZWwgdGhlIGN1cnJlbnQgQVBJIGNhbGwuXG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZjxBYm9ydENvbnRyb2xsZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcblxuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcblxuICAgICAgICBhd2FpdCBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZTogKCkgPT5cbiAgICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGFwaSxcbiAgICAgICAgICAgICAgY2hhdFJlcXVlc3QsXG4gICAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgICAgICAgICAgc3RyZWFtRGF0YSEsXG4gICAgICAgICAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICAgICAgICAgIGdlbmVyYXRlSWQsXG4gICAgICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3Q6IGNoYXRSZXF1ZXN0UGFyYW0gPT4ge1xuICAgICAgICAgICAgY2hhdFJlcXVlc3QgPSBjaGF0UmVxdWVzdFBhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICB9KTtcblxuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWdub3JlIGFib3J0IGVycm9ycyBhcyB0aGV5IGFyZSBleHBlY3RlZC5cbiAgICAgICAgaWYgKChlcnIgYXMgYW55KS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEVycm9yKGVyciBhcyBFcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbURhdGEsXG4gICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICBtZXNzYWdlc1JlZixcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgIGdlbmVyYXRlSWQsXG4gICAgXSxcbiAgKTtcblxuICBjb25zdCBhcHBlbmQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoXG4gICAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICAgIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnVuY3Rpb25zLFxuICAgICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgICB0b29scyxcbiAgICAgICAgdG9vbF9jaG9pY2UsXG4gICAgICAgIGRhdGEsXG4gICAgICB9OiBDaGF0UmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICApID0+IHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICBtZXNzYWdlLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdChtZXNzYWdlIGFzIE1lc3NhZ2UpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBkYXRhLFxuICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAuLi4odG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xzIH0pLFxuICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdCwgZ2VuZXJhdGVJZF0sXG4gICk7XG5cbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBmdW5jdGlvbnMsXG4gICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgdG9vbHMsXG4gICAgICB0b29sX2Nob2ljZSxcbiAgICB9OiBDaGF0UmVxdWVzdE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gUmVtb3ZlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2UgYW5kIHJldHJ5IGxhc3QgdXNlciBtZXNzYWdlLlxuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1JlZi5jdXJyZW50W21lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE1lc3NhZ2Uucm9sZSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICAgICAgY29uc3QgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0ID0ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgICAuLi4odG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xzIH0pLFxuICAgICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdLFxuICApO1xuXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzOiBNZXNzYWdlW10pID0+IHtcbiAgICAgIG11dGF0ZShtZXNzYWdlcywgZmFsc2UpO1xuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzO1xuICAgIH0sXG4gICAgW211dGF0ZV0sXG4gICk7XG5cbiAgLy8gSW5wdXQgc3RhdGUgYW5kIGhhbmRsZXJzLlxuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKGluaXRpYWxJbnB1dCk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgICBvcHRpb25zOiBDaGF0UmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICAgIG1ldGFkYXRhPzogT2JqZWN0LFxuICAgICkgPT4ge1xuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaW5wdXQpIHJldHVybjtcblxuICAgICAgYXBwZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgY29udGVudDogaW5wdXQsXG4gICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgICBzZXRJbnB1dCgnJyk7XG4gICAgfSxcbiAgICBbaW5wdXQsIGFwcGVuZF0sXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZTogYW55KSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzIHx8IFtdLFxuICAgIGVycm9yLFxuICAgIGFwcGVuZCxcbiAgICByZWxvYWQsXG4gICAgc3RvcCxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGRhdGE6IHN0cmVhbURhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBBc3Npc3RhbnRNZXNzYWdlLFxuICBEYXRhTWVzc2FnZSxcbiAgRnVuY3Rpb25DYWxsLFxuICBKU09OVmFsdWUsXG4gIFRvb2xDYWxsLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFN0cmVhbVN0cmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbVBhcnQ8Q09ERSBleHRlbmRzIHN0cmluZywgTkFNRSBleHRlbmRzIHN0cmluZywgVFlQRT4ge1xuICBjb2RlOiBDT0RFO1xuICBuYW1lOiBOQU1FO1xuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHsgdHlwZTogTkFNRTsgdmFsdWU6IFRZUEUgfTtcbn1cblxuY29uc3QgdGV4dFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzAnLCAndGV4dCcsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICcwJyxcbiAgbmFtZTogJ3RleHQnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInRleHRcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICcxJyxcbiAgJ2Z1bmN0aW9uX2NhbGwnLFxuICB7IGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbCB9XG4+ID0ge1xuICBjb2RlOiAnMScsXG4gIG5hbWU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnZnVuY3Rpb25fY2FsbCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbCAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fFxuICAgICAgISgnbmFtZScgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHxcbiAgICAgICEoJ2FyZ3VtZW50cycgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uX2NhbGwnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgZGF0YVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzInLCAnZGF0YScsIEFycmF5PEpTT05WYWx1ZT4+ID0ge1xuICBjb2RlOiAnMicsXG4gIG5hbWU6ICdkYXRhJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRhdGFcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogJ2RhdGEnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgZXJyb3JTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCczJywgJ2Vycm9yJywgc3RyaW5nPiA9IHtcbiAgY29kZTogJzMnLFxuICBuYW1lOiAnZXJyb3InLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAnZXJyb3InLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc0JyxcbiAgJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgQXNzaXN0YW50TWVzc2FnZVxuPiA9IHtcbiAgY29kZTogJzQnLFxuICBuYW1lOiAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdpZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdyb2xlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ2NvbnRlbnQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnJvbGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZS5yb2xlICE9PSAnYXNzaXN0YW50JyB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHxcbiAgICAgICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgICBpdGVtID0+XG4gICAgICAgICAgaXRlbSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ3R5cGUnIGluIGl0ZW0gJiZcbiAgICAgICAgICBpdGVtLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICAgICd0ZXh0JyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50ZXh0ICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbS50ZXh0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd2YWx1ZScgaW4gaXRlbS50ZXh0ICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiwgXCJyb2xlXCIsIGFuZCBcImNvbnRlbnRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyBBc3Npc3RhbnRNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc1JyxcbiAgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICB7XG4gICAgdGhyZWFkSWQ6IHN0cmluZztcbiAgICBtZXNzYWdlSWQ6IHN0cmluZztcbiAgfVxuPiA9IHtcbiAgY29kZTogJzUnLFxuICBuYW1lOiAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3RocmVhZElkJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ21lc3NhZ2VJZCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkLFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCc2JywgJ2RhdGFfbWVzc2FnZScsIERhdGFNZXNzYWdlPiA9IHtcbiAgY29kZTogJzYnLFxuICBuYW1lOiAnZGF0YV9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdkYXRhJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2RhdGEnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RhdGFfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgRGF0YU1lc3NhZ2UsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHRvb2xDYWxsU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzcnLFxuICAndG9vbF9jYWxscycsXG4gIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9XG4+ID0ge1xuICBjb2RlOiAnNycsXG4gIG5hbWU6ICd0b29sX2NhbGxzJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndG9vbF9jYWxscycgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHxcbiAgICAgIHZhbHVlLnRvb2xfY2FsbHMuc29tZSh0YyA9PiB7XG4gICAgICAgIHRjID09IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YgdGMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgISgnaWQnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAhKCd0eXBlJyBpbiB0YykgfHxcbiAgICAgICAgICB0eXBlb2YgdGMudHlwZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAhKCdmdW5jdGlvbicgaW4gdGMpIHx8XG4gICAgICAgICAgdGMuZnVuY3Rpb24gPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdhcmd1bWVudHMnIGluIHRjLmZ1bmN0aW9uKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Rvb2xfY2FsbHMnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgeyB0b29sX2NhbGxzOiBUb29sQ2FsbFtdIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc4JyxcbiAgJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLFxuICBBcnJheTxKU09OVmFsdWU+XG4+ID0ge1xuICBjb2RlOiAnOCcsXG4gIG5hbWU6ICdtZXNzYWdlX2Fubm90YXRpb25zJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3Qgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbl0gYXMgY29uc3Q7XG5cbi8vIHVuaW9uIHR5cGUgb2YgYWxsIHN0cmVhbSBwYXJ0c1xudHlwZSBTdHJlYW1QYXJ0cyA9XG4gIHwgdHlwZW9mIHRleHRTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZGF0YVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZXJyb3JTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydFxuICB8IHR5cGVvZiBkYXRhTWVzc2FnZVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgdG9vbENhbGxTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQ7XG4vKipcbiAqIE1hcHMgdGhlIHR5cGUgb2YgYSBzdHJlYW0gcGFydCB0byBpdHMgdmFsdWUgdHlwZS5cbiAqL1xudHlwZSBTdHJlYW1QYXJ0VmFsdWVUeXBlID0ge1xuICBbUCBpbiBTdHJlYW1QYXJ0cyBhcyBQWyduYW1lJ11dOiBSZXR1cm5UeXBlPFBbJ3BhcnNlJ10+Wyd2YWx1ZSddO1xufTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtUGFydFR5cGUgPVxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRleHRTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZGF0YVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZXJyb3JTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdG9vbENhbGxTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQucGFyc2U+O1xuXG5leHBvcnQgY29uc3Qgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBUaGUgbWFwIG9mIHByZWZpeGVzIGZvciBkYXRhIGluIHRoZSBzdHJlYW1cbiAqXG4gKiAtIDA6IFRleHQgZnJvbSB0aGUgTExNIHJlc3BvbnNlXG4gKiAtIDE6IChPcGVuQUkpIGZ1bmN0aW9uX2NhbGwgcmVzcG9uc2VzXG4gKiAtIDI6IGN1c3RvbSBKU09OIGFkZGVkIGJ5IHRoZSB1c2VyIHVzaW5nIGBEYXRhYFxuICogLSA2OiAoT3BlbkFJKSB0b29sX2NhbGwgcmVzcG9uc2VzXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogMDpWZXJjZWxcbiAqIDA6J3NcbiAqIDA6IEFJXG4gKiAwOiBBSVxuICogMDogU0RLXG4gKiAwOiBpcyBncmVhdFxuICogMDohXG4gKiAyOiB7IFwic29tZUpzb25cIjogXCJ2YWx1ZVwiIH1cbiAqIDE6IHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIiwgXCJhcmd1bWVudHNcIjogXCJ7XFxcXG5cXFxcXCJsb2NhdGlvblxcXFxcIjogXFxcXFwiQ2hhcmxvdHRlc3ZpbGxlLCBWaXJnaW5pYVxcXFxcIixcXFxcblxcXFxcImZvcm1hdFxcXFxcIjogXFxcXFwiY2Vsc2l1c1xcXFxcIlxcXFxufVwifX1cbiAqIDY6IHtcInRvb2xfY2FsbFwiOiB7XCJpZFwiOiBcInRvb2xfMFwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsIFwiYXJndW1lbnRzXCI6IFwie1xcXFxuXFxcXFwibG9jYXRpb25cXFxcXCI6IFxcXFxcIkNoYXJsb3R0ZXN2aWxsZSwgVmlyZ2luaWFcXFxcXCIsXFxcXG5cXFxcXCJmb3JtYXRcXFxcXCI6IFxcXFxcImNlbHNpdXNcXFxcXCJcXFxcbn1cIn19fVxuICpgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0Lm5hbWVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhU3RyZWFtUGFydC5uYW1lXTogZGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2Vycm9yU3RyZWFtUGFydC5uYW1lXTogZXJyb3JTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKHBhcnQgPT4gcGFydC5jb2RlKTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJlYW0gcGFydCBmcm9tIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBsaW5lIFRoZSBzdHJpbmcgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHN0cmVhbSBwYXJ0LlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgc3RyaW5nIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZVN0cmVhbVBhcnQgPSAobGluZTogc3RyaW5nKTogU3RyZWFtUGFydFR5cGUgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLicpO1xuICB9XG5cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcblxuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG5cbiAgY29uc3QgY29kZSA9IHByZWZpeCBhcyBrZXlvZiB0eXBlb2Ygc3RyZWFtUGFydHNCeUNvZGU7XG5cbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZTogSlNPTlZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuXG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcblxuLyoqXG4gKiBQcmVwZW5kcyBhIHN0cmluZyB3aXRoIGEgcHJlZml4IGZyb20gdGhlIGBTdHJlYW1DaHVua1ByZWZpeGVzYCwgSlNPTi1pZmllcyBpdCxcbiAqIGFuZCBhcHBlbmRzIGEgbmV3IGxpbmUuXG4gKlxuICogSXQgZW5zdXJlcyB0eXBlLXNhZmV0eSBmb3IgdGhlIHBhcnQgdHlwZSBhbmQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJlYW1QYXJ0PFQgZXh0ZW5kcyBrZXlvZiBTdHJlYW1QYXJ0VmFsdWVUeXBlPihcbiAgdHlwZTogVCxcbiAgdmFsdWU6IFN0cmVhbVBhcnRWYWx1ZVR5cGVbVF0sXG4pOiBTdHJlYW1TdHJpbmcge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZChwYXJ0ID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG5cbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxcbmA7XG59XG4iLCJpbXBvcnQgeyBTdHJlYW1QYXJ0VHlwZSwgcGFyc2VTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG5jb25zdCBORVdMSU5FID0gJ1xcbicuY2hhckNvZGVBdCgwKTtcblxuLy8gY29uY2F0ZW5hdGVzIGFsbCB0aGUgY2h1bmtzIGludG8gYSBzaW5nbGUgVWludDhBcnJheVxuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rczogVWludDhBcnJheVtdLCB0b3RhbExlbmd0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG5cbiAgcmV0dXJuIGNvbmNhdGVuYXRlZENodW5rcztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiByZWFkRGF0YVN0cmVhbShcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4sXG4gIHtcbiAgICBpc0Fib3J0ZWQsXG4gIH06IHtcbiAgICBpc0Fib3J0ZWQ/OiAoKSA9PiBib29sZWFuO1xuICB9ID0ge30sXG4pOiBBc3luY0dlbmVyYXRvcjxTdHJlYW1QYXJ0VHlwZT4ge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBub3RlOiB0aGlzIHNsaWdodGx5IG1vcmUgY29tcGxleCBhbGdvcml0aG0gaXMgcmVxdWlyZWRcbiAgLy8gdG8gcGFzcyB0aGUgdGVzdHMgaW4gdGhlIGVkZ2UgZW52aXJvbm1lbnQuXG5cbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgdG90YWxMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsYXN0IGNoYXJhY3RlciBpcyBub3QgYSBuZXdsaW5lLCB3ZSBoYXZlIG5vdCByZWFkIHRoZSB3aG9sZSBKU09OIHZhbHVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhazsgLy8gd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxuICAgIH1cblxuICAgIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKTtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBzdHJlYW1QYXJ0cyA9IGRlY29kZXJcbiAgICAgIC5kZWNvZGUoY29uY2F0ZW5hdGVkQ2h1bmtzLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICcnKSAvLyBzcGxpdHRpbmcgbGVhdmVzIGFuIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kXG4gICAgICAubWFwKHBhcnNlU3RyZWFtUGFydCk7XG5cbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMpIHtcbiAgICAgIHlpZWxkIHN0cmVhbVBhcnQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgaWYgKGlzQWJvcnRlZD8uKCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tICduYW5vaWQvbm9uLXNlY3VyZSc7XG5pbXBvcnQge1xuICBTdHJlYW1QYXJ0VHlwZSxcbiAgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHBhcnNlU3RyZWFtUGFydCxcbn0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG4vLyA3LWNoYXJhY3RlciByYW5kb20gc3RyaW5nXG5leHBvcnQgY29uc3QgbmFub2lkID0gY3VzdG9tQWxwaGFiZXQoXG4gICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG4gIDcsXG4pO1xuXG4vLyBzaW1wbGUgZGVjb2RlciBzaWduYXR1cmVzOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKCk6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4OiBmYWxzZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuLy8gY29tcGxleCBkZWNvZGVyIHNpZ25hdHVyZTpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogdHJ1ZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXTtcbi8vIGNvbWJpbmVkIHNpZ25hdHVyZSBmb3Igd2hlbiB0aGUgY2xpZW50IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCBhIGJvb2xlYW46XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg/OiBib29sZWFuLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBTdHJlYW1QYXJ0VHlwZVtdIHwgc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXg/OiBib29sZWFuKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICAgIGlmICghY2h1bmspIHJldHVybiAnJztcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlclxuICAgICAgLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAnJyk7IC8vIHNwbGl0dGluZyBsZWF2ZXMgYW4gZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmRcblxuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2h1bmtEZWNvZGVyIH07XG5cbmV4cG9ydCBjb25zdCBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlID0gKFxuICB0eXBlOiBrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHZhbHVlOiBzdHJpbmcsXG4pOiB2YWx1ZSBpcyBTdHJlYW1TdHJpbmcgPT5cbiAgdmFsdWUuc3RhcnRzV2l0aChgJHtTdHJlYW1TdHJpbmdQcmVmaXhlc1t0eXBlXX06YCkgJiYgdmFsdWUuZW5kc1dpdGgoJ1xcbicpO1xuXG5leHBvcnQgdHlwZSBTdHJlYW1TdHJpbmcgPVxuICBgJHsodHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzKVtrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXNdfToke3N0cmluZ31cXG5gO1xuXG4vKipcbiAqIEEgaGVhZGVyIHNlbnQgdG8gdGhlIGNsaWVudCBzbyBpdCBrbm93cyBob3cgdG8gaGFuZGxlIHBhcnNpbmcgdGhlIHN0cmVhbSAoYXMgYSBkZXByZWNhdGVkIHRleHQgcmVzcG9uc2Ugb3IgdXNpbmcgdGhlIG5ldyBwcmVmaXhlZCBwcm90b2NvbClcbiAqL1xuZXhwb3J0IGNvbnN0IENPTVBMRVhfSEVBREVSID0gJ1gtRXhwZXJpbWVudGFsLVN0cmVhbS1EYXRhJztcbiIsImltcG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcbmltcG9ydCB0eXBlIHsgRnVuY3Rpb25DYWxsLCBKU09OVmFsdWUsIE1lc3NhZ2UsIFRvb2xDYWxsIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICcuL3V0aWxzJztcblxudHlwZSBQcmVmaXhNYXAgPSB7XG4gIHRleHQ/OiBNZXNzYWdlO1xuICBmdW5jdGlvbl9jYWxsPzogTWVzc2FnZSAmIHtcbiAgICByb2xlOiAnYXNzaXN0YW50JztcbiAgICBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGw7XG4gIH07XG4gIHRvb2xfY2FsbHM/OiBNZXNzYWdlICYge1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnO1xuICAgIHRvb2xfY2FsbHM6IFRvb2xDYWxsW107XG4gIH07XG4gIGRhdGE6IEpTT05WYWx1ZVtdO1xufTtcblxuZnVuY3Rpb24gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2U8VCBleHRlbmRzIE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkPihcbiAgbWVzc2FnZTogVCxcbiAgYW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuKTogVCB7XG4gIGlmICghbWVzc2FnZSB8fCAhYW5ub3RhdGlvbnMgfHwgIWFubm90YXRpb25zLmxlbmd0aCkgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH0gYXMgVDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQgPSBuYW5vaWQsXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gbmV3IERhdGUoKSxcbn06IHtcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG4gIGFib3J0Q29udHJvbGxlclJlZj86IHtcbiAgICBjdXJyZW50OiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuICB9O1xuICB1cGRhdGU6IChtZXJnZWQ6IE1lc3NhZ2VbXSwgZGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIG9uRmluaXNoPzogKHByZWZpeE1hcDogUHJlZml4TWFwKSA9PiB2b2lkO1xuICBnZW5lcmF0ZUlkPzogKCkgPT4gc3RyaW5nO1xuICBnZXRDdXJyZW50RGF0ZT86ICgpID0+IERhdGU7XG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcDogUHJlZml4TWFwID0ge1xuICAgIGRhdGE6IFtdLFxuICB9O1xuXG4gIC8vIGtlZXAgbGlzdCBvZiBjdXJyZW50IG1lc3NhZ2UgYW5ub3RhdGlvbnMgZm9yIG1lc3NhZ2VcbiAgbGV0IG1lc3NhZ2VfYW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIC8vIHdlIGNyZWF0ZSBhIG1hcCBvZiBlYWNoIHByZWZpeCwgYW5kIGZvciBlYWNoIHByZWZpeGVkIG1lc3NhZ2Ugd2UgcHVzaCB0byB0aGUgbWFwXG4gIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmPy5jdXJyZW50ID09PSBudWxsLFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbJ3RleHQnXSkge1xuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSA9IHtcbiAgICAgICAgICAuLi5wcmVmaXhNYXBbJ3RleHQnXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwWyd0ZXh0J10uY29udGVudCB8fCAnJykgKyB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFsndGV4dCddID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlOiBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG51bGw7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uX2NhbGwnKSB7XG4gICAgICBwcmVmaXhNYXBbJ2Z1bmN0aW9uX2NhbGwnXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbJ2Z1bmN0aW9uX2NhbGwnXTtcbiAgICB9XG5cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlOiBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG51bGw7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3Rvb2xfY2FsbHMnKSB7XG4gICAgICBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICB0b29sX2NhbGxzOiB2YWx1ZS50b29sX2NhbGxzLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICB9O1xuXG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICBwcmVmaXhNYXBbJ2RhdGEnXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gcHJlZml4TWFwWyd0ZXh0J107XG5cbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2VfYW5ub3RhdGlvbnMnKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgYW55IGV4aXN0aW5nIG1lc3NhZ2Ugd2l0aCB0aGUgbGF0ZXN0IGFubm90YXRpb25zXG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLFxuICAgICAgKTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyxcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGtlZXBzIHRoZSBwcmVmaXhNYXAgdXAgdG8gZGF0ZSB3aXRoIHRoZSBsYXRlc3QgYW5ub3RhdGlvbnMsIGV2ZW4gaWYgYW5ub3RhdGlvbnMgcHJlY2VkZWQgdGhlIG1lc3NhZ2VcbiAgICBpZiAobWVzc2FnZV9hbm5vdGF0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5czogKGtleW9mIFByZWZpeE1hcClbXSA9IFtcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICAnZnVuY3Rpb25fY2FsbCcsXG4gICAgICAgICd0b29sX2NhbGxzJyxcbiAgICAgIF07XG4gICAgICBtZXNzYWdlUHJlZml4S2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwcmVmaXhNYXBba2V5XSkge1xuICAgICAgICAgIChwcmVmaXhNYXBba2V5XSBhcyBNZXNzYWdlKS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zIV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdlIGFkZCBmdW5jdGlvbiAmIHRvb2wgY2FsbHMgYW5kIHJlc3BvbnNlIG1lc3NhZ2VzIHRvIHRoZSBtZXNzYWdlc1tdLCBidXQgZGF0YSBpcyBpdHMgb3duIHRoaW5nXG4gICAgY29uc3QgbWVyZ2VkID0gW2Z1bmN0aW9uQ2FsbE1lc3NhZ2UsIHRvb2xDYWxsTWVzc2FnZSwgcmVzcG9uc2VNZXNzYWdlXVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLm1hcChtZXNzYWdlID0+ICh7XG4gICAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpLFxuICAgICAgfSkpIGFzIE1lc3NhZ2VbXTtcblxuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbJ2RhdGEnXV0pOyAvLyBtYWtlIGEgY29weSBvZiB0aGUgZGF0YSBhcnJheVxuICB9XG5cbiAgb25GaW5pc2g/LihwcmVmaXhNYXApO1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxscyxcbiAgICBdLmZpbHRlcihCb29sZWFuKSBhcyBNZXNzYWdlW10sXG4gICAgZGF0YTogcHJlZml4TWFwLmRhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBwYXJzZUNvbXBsZXhSZXNwb25zZSB9IGZyb20gJy4vcGFyc2UtY29tcGxleC1yZXNwb25zZSc7XG5pbXBvcnQge1xuICBGdW5jdGlvbkNhbGwsXG4gIElkR2VuZXJhdG9yLFxuICBKU09OVmFsdWUsXG4gIE1lc3NhZ2UsXG4gIFRvb2xDYWxsLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IENPTVBMRVhfSEVBREVSLCBjcmVhdGVDaHVua0RlY29kZXIgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxDaGF0QXBpKHtcbiAgYXBpLFxuICBtZXNzYWdlcyxcbiAgYm9keSxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgYXBwZW5kTWVzc2FnZSxcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBtZXNzYWdlczogT21pdDxNZXNzYWdlLCAnaWQnPltdO1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBjcmVkZW50aWFscz86IFJlcXVlc3RDcmVkZW50aWFscztcbiAgaGVhZGVycz86IEhlYWRlcnNJbml0O1xuICBhYm9ydENvbnRyb2xsZXI/OiAoKSA9PiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmU6ICgpID0+IHZvaWQ7XG4gIGFwcGVuZE1lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uVXBkYXRlOiAobWVyZ2VkOiBNZXNzYWdlW10sIGRhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBnZW5lcmF0ZUlkOiBJZEdlbmVyYXRvcjtcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIC4uLmJvZHksXG4gICAgfSksXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgfSxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlcj8uKCk/LnNpZ25hbCxcbiAgICBjcmVkZW50aWFscyxcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuXG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAoYXdhaXQgcmVzcG9uc2UudGV4dCgpKSB8fCAnRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLicsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gIH1cblxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBjb25zdCBpc0NvbXBsZXhNb2RlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoQ09NUExFWF9IRUFERVIpID09PSAndHJ1ZSc7XG5cbiAgaWYgKGlzQ29tcGxleE1vZGUpIHtcbiAgICByZXR1cm4gYXdhaXQgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgcmVhZGVyLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmOlxuICAgICAgICBhYm9ydENvbnRyb2xsZXIgIT0gbnVsbCA/IHsgY3VycmVudDogYWJvcnRDb250cm9sbGVyKCkgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICBvbkZpbmlzaChwcmVmaXhNYXApIHtcbiAgICAgICAgaWYgKG9uRmluaXNoICYmIHByZWZpeE1hcC50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICBvbkZpbmlzaChwcmVmaXhNYXAudGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUlkLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKGZhbHNlKTtcblxuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogUmVtb3ZlIHRoaXMgb25jZSBTdHJlYW0gRGF0YSBpcyBub3QgZXhwZXJpbWVudGFsXG4gICAgbGV0IHN0cmVhbWVkUmVzcG9uc2UgPSAnJztcbiAgICBjb25zdCByZXBseUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgfTtcblxuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogUmVtb3ZlIHRoaXMgb25jZSBTdHJlYW0gRGF0YSBpcyBub3QgZXhwZXJpbWVudGFsXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY2hhdCBzdGF0ZSB3aXRoIHRoZSBuZXcgbWVzc2FnZSB0b2tlbnMuXG4gICAgICBzdHJlYW1lZFJlc3BvbnNlICs9IGRlY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSkge1xuICAgICAgICAvLyBXaGlsZSB0aGUgZnVuY3Rpb24gY2FsbCBpcyBzdHJlYW1pbmcsIGl0IHdpbGwgYmUgYSBzdHJpbmcuXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVsnZnVuY3Rpb25fY2FsbCddID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpIHtcbiAgICAgICAgLy8gV2hpbGUgdGhlIHRvb2wgY2FsbHMgYXJlIHN0cmVhbWluZywgaXQgd2lsbCBiZSBhIHN0cmluZy5cbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlWyd0b29sX2NhbGxzJ10gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlWydjb250ZW50J10gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICBhcHBlbmRNZXNzYWdlKHsgLi4ucmVzcG9uc2VNZXNzYWdlIH0pO1xuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXI/LigpID09PSBudWxsKSB7XG4gICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICAvLyBPbmNlIHRoZSBzdHJlYW0gaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBjYWxsIGlzIHBhcnNlZCBpbnRvIGFuIG9iamVjdC5cbiAgICAgIGNvbnN0IHBhcnNlZEZ1bmN0aW9uQ2FsbDogRnVuY3Rpb25DYWxsID1cbiAgICAgICAgSlNPTi5wYXJzZShzdHJlYW1lZFJlc3BvbnNlKS5mdW5jdGlvbl9jYWxsO1xuXG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ2Z1bmN0aW9uX2NhbGwnXSA9IHBhcnNlZEZ1bmN0aW9uQ2FsbDtcblxuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKSB7XG4gICAgICAvLyBPbmNlIHRoZSBzdHJlYW0gaXMgY29tcGxldGUsIHRoZSB0b29sIGNhbGxzIGFyZSBwYXJzZWQgaW50byBhbiBhcnJheS5cbiAgICAgIGNvbnN0IHBhcnNlZFRvb2xDYWxsczogVG9vbENhbGxbXSA9XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyZWFtZWRSZXNwb25zZSkudG9vbF9jYWxscztcblxuICAgICAgcmVzcG9uc2VNZXNzYWdlWyd0b29sX2NhbGxzJ10gPSBwYXJzZWRUb29sQ2FsbHM7XG5cbiAgICAgIGFwcGVuZE1lc3NhZ2UoeyAuLi5yZXNwb25zZU1lc3NhZ2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZU1lc3NhZ2U7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENoYXRSZXF1ZXN0LFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzLFxufToge1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PiBQcm9taXNlPFxuICAgIE1lc3NhZ2UgfCB7IG1lc3NhZ2VzOiBNZXNzYWdlW107IGRhdGE6IEpTT05WYWx1ZVtdIH1cbiAgPjtcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsPzogKFxuICAgIGNoYXRNZXNzYWdlczogTWVzc2FnZVtdLFxuICAgIGZ1bmN0aW9uQ2FsbDogRnVuY3Rpb25DYWxsLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGw/OiAoXG4gICAgY2hhdE1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gICAgdG9vbENhbGxzOiBUb29sQ2FsbFtdLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgdXBkYXRlQ2hhdFJlcXVlc3Q6IChjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QpID0+IHZvaWQ7XG4gIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gTWVzc2FnZVtdO1xufSkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogVGhpcyBzaG91bGQgYmUgeyAgY29uc3QgeyBtZXNzYWdlczogc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2VzLCBkYXRhIH0gPVxuICAgIC8vIGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UofSBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSgpO1xuXG4gICAgLy8gVXNpbmcgZXhwZXJpbWVudGFsIHN0cmVhbSBkYXRhXG4gICAgaWYgKCdtZXNzYWdlcycgaW4gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSkge1xuICAgICAgbGV0IGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbWVzc2FnZSBoYXMgYSBjb21wbGV0ZSBmdW5jdGlvbiBjYWxsIG9yIHRvb2wgY2FsbFxuICAgICAgICBpZiAoXG4gICAgICAgICAgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAobWVzc2FnZS50b29sX2NhbGxzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLnRvb2xfY2FsbHMgPT09ICdzdHJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJ5IHRvIGhhbmRsZSBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9uQ2FsbCBpcyBhbiBvYmplY3RcbiAgICAgICAgICAvLyBJZiBub3QsIHdlIGdvdCB0b29sIGNhbGxzIGluc3RlYWQgb2YgZnVuY3Rpb24gY2FsbHNcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uQ2FsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlciBoYW5kbGVzIHRoZSBmdW5jdGlvbiBjYWxsIGluIHRoZWlyIG93biBmdW5jdGlvbkNhbGxIYW5kbGVyLlxuICAgICAgICAgIC8vIFRoZSBcImFyZ3VtZW50c1wiIGtleSBvZiB0aGUgZnVuY3Rpb24gY2FsbCBvYmplY3Qgd2lsbCBzdGlsbCBiZSBhIHN0cmluZyB3aGljaCB3aWxsIGhhdmUgdG8gYmUgcGFyc2VkIGluIHRoZSBmdW5jdGlvbiBoYW5kbGVyLlxuICAgICAgICAgIC8vIElmIHRoZSBcImFyZ3VtZW50c1wiIEpTT04gaXMgbWFsZm9ybWVkIGR1ZSB0byBtb2RlbCBlcnJvciB0aGUgdXNlciB3aWxsIGhhdmUgdG8gaGFuZGxlIHRoYXQgdGhlbXNlbHZlcy5cblxuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3YXMgcmV0dXJuZWQuXG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gaGFuZGxlIHRvb2wgY2FsbFxuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2xDYWxscyBpcyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgICAgLy8gSWYgbm90LCB3ZSBnb3QgZnVuY3Rpb24gY2FsbHMgaW5zdGVhZCBvZiB0b29sIGNhbGxzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodG9vbENhbGxzKSB8fFxuICAgICAgICAgICAgdG9vbENhbGxzLnNvbWUodG9vbENhbGwgPT4gdHlwZW9mIHRvb2xDYWxsICE9PSAnb2JqZWN0JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vblRvb2xDYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2VyIGhhbmRsZXMgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gdGhlaXIgb3duIGZ1bmN0aW9uQ2FsbEhhbmRsZXIuXG4gICAgICAgICAgLy8gVGhlIFwiYXJndW1lbnRzXCIga2V5IG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9iamVjdCB3aWxsIHN0aWxsIGJlIGEgc3RyaW5nIHdoaWNoIHdpbGwgaGF2ZSB0byBiZSBwYXJzZWQgaW4gdGhlIGZ1bmN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgLy8gSWYgdGhlIFwiYXJndW1lbnRzXCIgSlNPTiBpcyBtYWxmb3JtZWQgZHVlIHRvIG1vZGVsIGVycm9yIHRoZSB1c2VyIHdpbGwgaGF2ZSB0byBoYW5kbGUgdGhhdCB0aGVtc2VsdmVzLlxuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzRm9sbG93aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZTtcblxuICAgICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBSZW1vdmUgdGhpcyBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICAgIGlmIChcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSAnc3RyaW5nJylcbiAgICAgICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgYW5kIGFyZSBleHBlY3RpbmcgYSBmdW5jdGlvbiBjYWxsLCB0aGUgbWVzc2FnZSBzaG91bGQgaGF2ZSBvbmUsIGlmIG5vdCB3YXJuIGFuZCBjb250aW51ZVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICBpZiAoISh0eXBlb2YgZnVuY3Rpb25DYWxsID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgZnVuY3Rpb25DYWxsKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgYXJlIGV4cGVjdGluZyBhIHRvb2wgY2FsbCwgdGhlIG1lc3NhZ2Ugc2hvdWxkIGhhdmUgb25lLCBpZiBub3Qgd2FybiBhbmQgY29udGludWVcbiAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICBpZiAoISh0eXBlb2YgdG9vbENhbGxzID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgZnVuY3Rpb25zJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHModG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIHNlbnQgYmFjayB0byB0aGUgQVBJIGFzIGEgc3RyaW5nXG4gICAgICBmdW5jdGlvbiBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMocmVzcG9uc2U6IENoYXRSZXF1ZXN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDb21wbGV0aW9uQXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGknO1xuaW1wb3J0IHtcbiAgSlNPTlZhbHVlLFxuICBSZXF1ZXN0T3B0aW9ucyxcbiAgVXNlQ29tcGxldGlvbk9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFVzZUNvbXBsZXRpb25IZWxwZXJzID0ge1xuICAvKiogVGhlIGN1cnJlbnQgY29tcGxldGlvbiByZXN1bHQgKi9cbiAgY29tcGxldGlvbjogc3RyaW5nO1xuICAvKipcbiAgICogU2VuZCBhIG5ldyBwcm9tcHQgdG8gdGhlIEFQSSBlbmRwb2ludCBhbmQgdXBkYXRlIHRoZSBjb21wbGV0aW9uIHN0YXRlLlxuICAgKi9cbiAgY29tcGxldGU6IChcbiAgICBwcm9tcHQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqIFRoZSBlcnJvciBvYmplY3Qgb2YgdGhlIEFQSSByZXF1ZXN0ICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCBFcnJvcjtcbiAgLyoqXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IEFQSSByZXF1ZXN0IGJ1dCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zLlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYGNvbXBsZXRpb25gIHN0YXRlIGxvY2FsbHkuXG4gICAqL1xuICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICAvKiogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0ICovXG4gIGlucHV0OiBzdHJpbmc7XG4gIC8qKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcbiAgLyoqXG4gICAqIEFuIGlucHV0L3RleHRhcmVhLXJlYWR5IG9uQ2hhbmdlIGhhbmRsZXIgdG8gY29udHJvbCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiA8aW5wdXQgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfSB2YWx1ZT17aW5wdXR9IC8+XG4gICAqIGBgYFxuICAgKi9cbiAgaGFuZGxlSW5wdXRDaGFuZ2U6IChcbiAgICBlOlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuICAvKipcbiAgICogRm9ybSBzdWJtaXNzaW9uIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSByZXNldCBpbnB1dCBhbmQgYXBwZW5kIGEgdXNlciBtZXNzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cbiAgICogIDxpbnB1dCBvbkNoYW5nZT17aGFuZGxlSW5wdXRDaGFuZ2V9IHZhbHVlPXtpbnB1dH0gLz5cbiAgICogPC9mb3JtPlxuICAgKiBgYGBcbiAgICovXG4gIGhhbmRsZVN1Ym1pdDogKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB2b2lkO1xuICAvKiogV2hldGhlciB0aGUgQVBJIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBkYXRhIGFkZGVkIG9uIHRoZSBzZXJ2ZXIgdmlhIFN0cmVhbURhdGEgKi9cbiAgZGF0YT86IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSAnL2FwaS9jb21wbGV0aW9uJyxcbiAgaWQsXG4gIGluaXRpYWxDb21wbGV0aW9uID0gJycsXG4gIGluaXRpYWxJbnB1dCA9ICcnLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG59OiBVc2VDb21wbGV0aW9uT3B0aW9ucyA9IHt9KTogVXNlQ29tcGxldGlvbkhlbHBlcnMge1xuICAvLyBHZW5lcmF0ZSBhbiB1bmlxdWUgaWQgZm9yIHRoZSBjb21wbGV0aW9uIGlmIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgfHwgaG9va0lkO1xuXG4gIC8vIFN0b3JlIHRoZSBjb21wbGV0aW9uIHN0YXRlIGluIFNXUiwgdXNpbmcgdGhlIGNvbXBsZXRpb25JZCBhcyB0aGUga2V5IHRvIHNoYXJlIHN0YXRlcy5cbiAgY29uc3QgeyBkYXRhLCBtdXRhdGUgfSA9IHVzZVNXUjxzdHJpbmc+KFthcGksIGNvbXBsZXRpb25JZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxDb21wbGV0aW9uLFxuICB9KTtcblxuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjxib29sZWFuPihcbiAgICBbY29tcGxldGlvbklkLCAnbG9hZGluZyddLFxuICAgIG51bGwsXG4gICk7XG5cbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjxcbiAgICBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZFxuICA+KFtjb21wbGV0aW9uSWQsICdzdHJlYW1EYXRhJ10sIG51bGwpO1xuXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8dW5kZWZpbmVkIHwgRXJyb3I+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IGNvbXBsZXRpb24gPSBkYXRhITtcblxuICAvLyBBYm9ydCBjb250cm9sbGVyIHRvIGNhbmNlbCB0aGUgY3VycmVudCBBUEkgY2FsbC5cbiAgY29uc3QgW2Fib3J0Q29udHJvbGxlciwgc2V0QWJvcnRDb250cm9sbGVyXSA9XG4gICAgdXNlU3RhdGU8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuXG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHByb21wdDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpID0+XG4gICAgICBjYWxsQ29tcGxldGlvbkFwaSh7XG4gICAgICAgIGFwaSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgICAgICAuLi5vcHRpb25zPy5ib2R5LFxuICAgICAgICB9LFxuICAgICAgICBzZXRDb21wbGV0aW9uOiBjb21wbGV0aW9uID0+IG11dGF0ZShjb21wbGV0aW9uLCBmYWxzZSksXG4gICAgICAgIHNldExvYWRpbmc6IG11dGF0ZUxvYWRpbmcsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkRhdGE6IGRhdGEgPT4ge1xuICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLihzdHJlYW1EYXRhIHx8IFtdKSwgLi4uKGRhdGEgfHwgW10pXSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlcikge1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgfVxuICB9LCBbYWJvcnRDb250cm9sbGVyXSk7XG5cbiAgY29uc3Qgc2V0Q29tcGxldGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIChjb21wbGV0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIG11dGF0ZShjb21wbGV0aW9uLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXSxcbiAgKTtcblxuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrPFVzZUNvbXBsZXRpb25IZWxwZXJzWydjb21wbGV0ZSddPihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF0sXG4gICk7XG5cbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIChlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlKGlucHV0KTtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdLFxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGU6IGFueSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNvbXBsZXRpb24sXG4gICAgY29tcGxldGUsXG4gICAgZXJyb3IsXG4gICAgc2V0Q29tcGxldGlvbixcbiAgICBzdG9wLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcbmltcG9ydCB7IEpTT05WYWx1ZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQ09NUExFWF9IRUFERVIsIGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBvbkRhdGEsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBwcm9tcHQ6IHN0cmluZztcbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gIGhlYWRlcnM/OiBIZWFkZXJzSW5pdDtcbiAgYm9keTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgc2V0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0TG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldEVycm9yOiAoZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBzZXRBYm9ydENvbnRyb2xsZXI6IChhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGwpID0+IHZvaWQ7XG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25GaW5pc2g/OiAocHJvbXB0OiBzdHJpbmcsIGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIG9uRGF0YT86IChkYXRhOiBKU09OVmFsdWVbXSkgPT4gdm9pZDtcbn0pIHtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG5cbiAgICAvLyBFbXB0eSB0aGUgY29tcGxldGlvbiBpbW1lZGlhdGVseS5cbiAgICBzZXRDb21wbGV0aW9uKCcnKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keSxcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG5cbiAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoYXdhaXQgcmVzLnRleHQoKSkgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXMuaGVhZGVycy5nZXQoQ09NUExFWF9IRUFERVIpID09PSAndHJ1ZSc7XG5cbiAgICBpZiAoaXNDb21wbGV4TW9kZSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyID09PSBudWxsLFxuICAgICAgfSkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdkYXRhJzoge1xuICAgICAgICAgICAgb25EYXRhPy4odmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29tcGxldGlvbiBzdGF0ZSB3aXRoIHRoZSBuZXcgbWVzc2FnZSB0b2tlbnMuXG4gICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChwcm9tcHQsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElnbm9yZSBhYm9ydCBlcnJvcnMgYXMgdGhleSBhcmUgZXhwZWN0ZWQuXG4gICAgaWYgKChlcnIgYXMgYW55KS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEVycm9yKGVyciBhcyBFcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzICovXG5cbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuLi9zaGFyZWQvcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgQXNzaXN0YW50U3RhdHVzID0gJ2luX3Byb2dyZXNzJyB8ICdhd2FpdGluZ19tZXNzYWdlJztcblxuZXhwb3J0IHR5cGUgVXNlQXNzaXN0YW50SGVscGVycyA9IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGFycmF5IG9mIGNoYXQgbWVzc2FnZXMuXG4gICAqL1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB0aHJlYWQgSUQuXG4gICAqL1xuICB0aHJlYWRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZmllbGQuXG4gICAqL1xuICBpbnB1dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlLlxuICAgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB0aGUgYG9uQ2hhbmdlYCBldmVudCBvZiB0aGUgaW5wdXQgZmllbGQgdG8gY29udHJvbCB0aGUgaW5wdXQncyB2YWx1ZS5cbiAgICovXG4gIGhhbmRsZUlucHV0Q2hhbmdlOiAoXG4gICAgZXZlbnQ6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEZvcm0gc3VibWlzc2lvbiBoYW5kbGVyIHRoYXQgYXV0b21hdGljYWxseSByZXNldHMgdGhlIGlucHV0IGZpZWxkIGFuZCBhcHBlbmRzIGEgdXNlciBtZXNzYWdlLlxuICAgKi9cbiAgc3VibWl0TWVzc2FnZTogKFxuICAgIGV2ZW50PzogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgcmVxdWVzdE9wdGlvbnM/OiB7XG4gICAgICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB9LFxuICApID0+IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNob3cgYSBsb2FkaW5nIGluZGljYXRvci5cbiAgICovXG4gIHN0YXR1czogQXNzaXN0YW50U3RhdHVzO1xuXG4gIC8qKlxuICAgKiBUaGUgZXJyb3IgdGhyb3duIGR1cmluZyB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgcHJvY2Vzc2luZywgaWYgYW55LlxuICAgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IHVua25vd247XG59O1xuXG5leHBvcnQgdHlwZSBVc2VBc3Npc3RhbnRPcHRpb25zID0ge1xuICAvKipcbiAgICogVGhlIEFQSSBlbmRwb2ludCB0aGF0IGFjY2VwdHMgYSBgeyB0aHJlYWRJZDogc3RyaW5nIHwgbnVsbDsgbWVzc2FnZTogc3RyaW5nOyB9YCBvYmplY3QgYW5kIHJldHVybnMgYW4gYEFzc2lzdGFudFJlc3BvbnNlYCBzdHJlYW0uXG4gICAqIFRoZSB0aHJlYWRJZCByZWZlcnMgdG8gYW4gZXhpc3RpbmcgdGhyZWFkIHdpdGggbWVzc2FnZXMgKG9yIGlzIGBudWxsYCB0byBjcmVhdGUgYSBuZXcgdGhyZWFkKS5cbiAgICogVGhlIG1lc3NhZ2UgaXMgdGhlIG5leHQgbWVzc2FnZSB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgdGhyZWFkIGFuZCBzZW50IHRvIHRoZSBhc3Npc3RhbnQuXG4gICAqL1xuICBhcGk6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgSUQgb2YgYW4gZXhpc3RpbmcgdGhyZWFkLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWRJZD86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGl0ZXJhbCB0aGF0IHNldHMgdGhlIG1vZGUgb2YgY3JlZGVudGlhbHMgdG8gYmUgdXNlZCBvbiB0aGUgcmVxdWVzdC5cbiAgICogRGVmYXVsdHMgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgKi9cbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG9iamVjdCBvZiBoZWFkZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgQVBJIGVuZHBvaW50LlxuICAgKi9cbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBIZWFkZXJzO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBib2R5IG9iamVjdCB0byBiZSBwYXNzZWQgdG8gdGhlIEFQSSBlbmRwb2ludC5cbiAgICovXG4gIGJvZHk/OiBvYmplY3Q7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXNzaXN0YW50IGVuY291bnRlcnMgYW4gZXJyb3IuXG4gICAqL1xuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50KHtcbiAgYXBpLFxuICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIG9uRXJyb3IsXG59OiBVc2VBc3Npc3RhbnRPcHRpb25zKTogVXNlQXNzaXN0YW50SGVscGVycyB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbdGhyZWFkSWQsIHNldFRocmVhZElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlPEFzc2lzdGFudFN0YXR1cz4oJ2F3YWl0aW5nX21lc3NhZ2UnKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBFcnJvcj4odW5kZWZpbmVkKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChcbiAgICBldmVudDpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4ge1xuICAgIHNldElucHV0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgY29uc3Qgc3VibWl0TWVzc2FnZSA9IGFzeW5jIChcbiAgICBldmVudD86IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiB7XG4gICAgZXZlbnQ/LnByZXZlbnREZWZhdWx0Py4oKTtcblxuICAgIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRTdGF0dXMoJ2luX3Byb2dyZXNzJyk7XG5cbiAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiBbXG4gICAgICAuLi5tZXNzYWdlcyxcbiAgICAgIHsgaWQ6ICcnLCByb2xlOiAndXNlcicsIGNvbnRlbnQ6IGlucHV0IH0sXG4gICAgXSk7XG5cbiAgICBzZXRJbnB1dCgnJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIC4uLmhlYWRlcnMgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgLi4uYm9keSxcbiAgICAgICAgLy8gYWx3YXlzIHVzZSB1c2VyLXByb3ZpZGVkIHRocmVhZElkIHdoZW4gYXZhaWxhYmxlOlxuICAgICAgICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSA/PyB0aHJlYWRJZCA/PyBudWxsLFxuICAgICAgICBtZXNzYWdlOiBpbnB1dCxcblxuICAgICAgICAvLyBvcHRpb25hbCByZXF1ZXN0IGRhdGE6XG4gICAgICAgIGRhdGE6IHJlcXVlc3RPcHRpb25zPy5kYXRhLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAocmVzdWx0LmJvZHkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0oXG4gICAgICAgIHJlc3VsdC5ib2R5LmdldFJlYWRlcigpLFxuICAgICAgKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdhc3Npc3RhbnRfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RhdGFfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQgPz8gJycsXG4gICAgICAgICAgICAgICAgcm9sZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnOiB7XG4gICAgICAgICAgICBzZXRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpZCBvZiBsYXN0IG1lc3NhZ2U6XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VzLmxlbmd0aCAtIDEpLCBsYXN0TWVzc2FnZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG5ldyBFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck9iaik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgc2V0RXJyb3IoZXJyb3IgYXMgRXJyb3IpO1xuICAgIH1cblxuICAgIHNldFN0YXR1cygnYXdhaXRpbmdfbWVzc2FnZScpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgdGhyZWFkSWQsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwidmFsdWUiLCJFcnJvciIsInR5cGUiLCJmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0IiwiZnVuY3Rpb25fY2FsbCIsImFyZ3VtZW50cyIsImRhdGFTdHJlYW1QYXJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JTdHJlYW1QYXJ0IiwiYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQiLCJpZCIsInJvbGUiLCJjb250ZW50IiwiZXZlcnkiLCJpdGVtIiwidGV4dCIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJtYXAiLCJwYXJ0IiwicGFyc2VTdHJlYW1QYXJ0IiwibGluZSIsImZpcnN0U2VwYXJhdG9ySW5kZXgiLCJpbmRleE9mIiwicHJlZml4Iiwic2xpY2UiLCJpbmNsdWRlcyIsInRleHRWYWx1ZSIsImpzb25WYWx1ZSIsIkpTT04iLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwibGVuZ3RoIiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZWFkIiwicHVzaCIsImRlY29kZSIsInN0cmVhbSIsInNwbGl0IiwiZmlsdGVyIiwic3RyZWFtUGFydCIsImNhbmNlbCIsImN1c3RvbUFscGhhYmV0IiwibmFub2lkIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZWQiLCJCb29sZWFuIiwiQ09NUExFWF9IRUFERVIiLCJhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZSIsIm1lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZW5lcmF0ZUlkIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwiY3JlYXRlZEF0IiwicHJlZml4TWFwIiwiZGF0YSIsIm1lc3NhZ2VfYW5ub3RhdGlvbnMiLCJjdXJyZW50IiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsInRvb2xDYWxsTWVzc2FnZSIsInJlc3BvbnNlTWVzc2FnZSIsIm1lc3NhZ2VQcmVmaXhLZXlzIiwiZm9yRWFjaCIsImtleSIsIm1lcmdlZCIsIm1lc3NhZ2VzIiwiY2FsbENoYXRBcGkiLCJhcGkiLCJib2R5IiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwiYXBwZW5kTWVzc2FnZSIsInJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSIsIm9uUmVzcG9uc2UiLCJvblVwZGF0ZSIsIl9hIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsInN0cmluZ2lmeSIsInNpZ25hbCIsImNhdGNoIiwiZXJyIiwib2siLCJnZXRSZWFkZXIiLCJpc0NvbXBsZXhNb2RlIiwiZ2V0Iiwic3RyZWFtZWRSZXNwb25zZSIsInJlcGx5SWQiLCJkb25lIiwic3RhcnRzV2l0aCIsInBhcnNlZEZ1bmN0aW9uQ2FsbCIsInBhcnNlZFRvb2xDYWxscyIsInByb2Nlc3NDaGF0U3RyZWFtIiwiZ2V0U3RyZWFtZWRSZXNwb25zZSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwidXBkYXRlQ2hhdFJlcXVlc3QiLCJnZXRDdXJyZW50TWVzc2FnZXMiLCJtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlIiwiaGFzRm9sbG93aW5nUmVzcG9uc2UiLCJmdW5jdGlvbkNhbGwiLCJjb25zb2xlIiwid2FybiIsImZ1bmN0aW9uQ2FsbFJlc3BvbnNlIiwidG9vbENhbGxzIiwidG9vbENhbGwiLCJ0b29sQ2FsbFJlc3BvbnNlIiwiZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzIiwic3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UiLCJjaGF0UmVxdWVzdCIsIm11dGF0ZSIsIm11dGF0ZVN0cmVhbURhdGEiLCJleGlzdGluZ0RhdGEiLCJleHRyYU1ldGFkYXRhUmVmIiwibWVzc2FnZXNSZWYiLCJzZW5kRXh0cmFNZXNzYWdlRmllbGRzIiwiX2IiLCJwcmV2aW91c01lc3NhZ2VzIiwiY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQiLCJ0b29sX2NhbGxfaWQiLCJyZWFkUm93IiwicHJvbWlzZSIsInVpIiwibmV4dCIsImUiLCJvcHRpb25zIiwiZnVuY3Rpb25zIiwidG9vbHMiLCJ0b29sX2Nob2ljZSIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiaWRLZXkiLCJjaGF0S2V5IiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJyZXN1bHQiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGUiLCJleHBlcmltZW50YWxfdXNlQXNzaXN0YW50IiwidGhyZWFkSWRQYXJhbSIsInNldFRocmVhZElkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZXZlbnQiLCJzdWJtaXRNZXNzYWdlIiwicmVxdWVzdE9wdGlvbnMiLCJjYWxsIiwiZXJyb3JPYmoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;